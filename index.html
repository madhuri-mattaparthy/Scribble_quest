<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scribble Quest - Ainia AI Game Prototype</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        user-select: none;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
      }

      body {
        font-family: "Comic Neue", cursive, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        height: 100vh;
        overflow: hidden;
        position: relative;
      }

      .game-container {
        width: 100%;
        height: 100vh;
        background: white;
        position: relative;
        display: flex;
        flex-direction: column;
      }

      .header {
        background: linear-gradient(45deg, #ff6b6b, #ffa500);
        padding: 15px;
        text-align: center;
        color: white;
        position: relative;
        z-index: 100;
      }

      .header h1 {
        font-size: 2em;
        margin-bottom: 5px;
      }

      .level-info {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: rgba(255, 255, 255, 0.2);
        padding: 10px 20px;
        border-radius: 20px;
      }

      .challenge-area {
        background: linear-gradient(135deg, #74b9ff, #0984e3);
        color: white;
        padding: 20px;
        text-align: center;
        font-size: 1.3em;
        font-weight: bold;
        position: relative;
        z-index: 50;
      }

      .drawing-canvas {
        flex: 1;
        background: #f8f9fa;
        position: relative;
        cursor: crosshair;
        overflow: hidden;
      }

      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      .ai-character {
        position: absolute;
        width: 120px;
        height: 120px;
        background: radial-gradient(circle, #ff6b6b, #ffa500);
        border-radius: 50%;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        transition: all 0.5s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 3em;
        color: white;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 30;
        box-shadow: 0 10px 30px rgba(255, 107, 107, 0.5);
      }

      .ai-character.show {
        transform: translate(-50%, -50%) scale(1);
        animation: bounce 1s ease infinite alternate;
      }

      @keyframes bounce {
        0% {
          transform: translate(-50%, -50%) scale(1);
        }
        100% {
          transform: translate(-50%, -50%) scale(1.1);
        }
      }

      .controls {
        background: white;
        padding: 15px;
        display: flex;
        gap: 10px;
        justify-content: center;
        align-items: center;
        border-top: 2px solid #ddd;
        z-index: 100;
        position: relative;
      }

      .btn {
        padding: 12px 20px;
        border: none;
        border-radius: 25px;
        font-size: 1.1em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        font-family: inherit;
      }

      .btn-primary {
        background: linear-gradient(45deg, #00b894, #00a085);
        color: white;
      }

      .btn-secondary {
        background: linear-gradient(45deg, #74b9ff, #0984e3);
        color: white;
      }

      .btn-danger {
        background: linear-gradient(45deg, #e17055, #d63031);
        color: white;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
      }

      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .timer {
        background: #ffeaa7;
        border: 3px solid #fdcb6e;
        padding: 8px 15px;
        border-radius: 20px;
        font-size: 1.2em;
        font-weight: bold;
        color: #2d3436;
      }

      .celebration {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.95);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 200;
        animation: fadeIn 0.5s ease;
        overflow-y: auto;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .celebration h2 {
        font-size: 3em;
        color: #00b894;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
      }

      .celebration p {
        font-size: 1.5em;
        color: #2d3436;
        margin-bottom: 30px;
        text-align: center;
        max-width: 80%;
      }

      .stars {
        font-size: 2em;
        margin: 20px 0;
      }

      .instruction {
        background: #dda0dd;
        color: white;
        padding: 15px;
        text-align: center;
        font-size: 1.1em;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        border-radius: 15px;
        max-width: 80%;
        z-index: 40;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      }

      .drawing-hint {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.9);
        padding: 10px 20px;
        border-radius: 20px;
        font-size: 1em;
        color: #2d3436;
        border: 2px solid #74b9ff;
        z-index: 30;
      }

      .progress-bar {
        background: #e9ecef;
        height: 8px;
        border-radius: 4px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        background: linear-gradient(45deg, #00b894, #00a085);
        height: 100%;
        transition: width 0.5s ease;
        border-radius: 4px;
      }

      .game-state {
        position: absolute;
        top: 10px;
        right: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 10px;
        font-size: 0.9em;
        z-index: 100;
      }

      .particle {
        position: absolute;
        pointer-events: none;
        font-size: 1.5em;
        z-index: 150;
        animation: particle-float 2s ease-out forwards;
      }

      @keyframes particle-float {
        0% {
          transform: translateY(0) scale(1);
          opacity: 1;
        }
        100% {
          transform: translateY(-100px) scale(1.5);
          opacity: 0;
        }
      }

      .backend-status {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(255, 255, 255, 0.9);
        padding: 10px;
        border-radius: 10px;
        font-size: 0.8em;
        z-index: 100;
      }

      .status-connected {
        color: #00b894;
      }

      .status-disconnected {
        color: #e17055;
      }

      .notification {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #00b894;
        color: white;
        padding: 15px 20px;
        border-radius: 10px;
        z-index: 1000;
        font-size: 14px;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        animation: slideIn 0.3s ease;
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }

      .loading {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        color: #74b9ff;
        font-size: 1.5em;
        z-index: 50;
      }

      /* New styles for DALL-E reward images */
      .reward-container {
        margin-top: 20px;
        text-align: center;
      }

      .reward-container img {
        transition: transform 0.3s ease;
        max-width: 300px;
        max-height: 300px;
        border-radius: 15px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        border: 3px solid #00b894;
      }

      .reward-container img:hover {
        transform: scale(1.05);
      }

      .reward-text {
        margin-top: 10px;
        font-weight: bold;
        color: #00b894;
        font-size: 1.2em;
      }

      .loading-spinner {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #00b894;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-left: 10px;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      @media (max-width: 768px) {
        .header h1 {
          font-size: 1.5em;
        }
        .challenge-area {
          font-size: 1.1em;
          padding: 15px;
        }
        .btn {
          padding: 10px 15px;
          font-size: 1em;
        }
        .ai-character {
          width: 100px;
          height: 100px;
          font-size: 2.5em;
        }
        .reward-container img {
          max-width: 250px;
          max-height: 250px;
        }
      }
    </style>
  </head>
  <body>
    <div class="game-container">
      <div class="header">
        <h1>üé® Scribble Quest</h1>
        <div class="level-info">
          <span>Level: <span id="levelNumber">1</span></span>
          <span class="timer">‚è∞ <span id="timer">30</span>s</span>
          <span>Score: <span id="score">0</span></span>
        </div>
      </div>

      <div class="challenge-area" id="challengeText">
        üåü Loading AI-generated challenge...
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressFill" style="width: 20%"></div>
      </div>

      <div class="drawing-canvas" id="drawingCanvas">
        <canvas id="canvas"></canvas>

        <div class="instruction" id="instruction">
          ‚úèÔ∏è Use your finger or mouse to draw! Make it as simple or crazy as you
          want!
        </div>

        <div class="ai-character" id="aiCharacter">ü¶ã</div>

        <div class="drawing-hint" id="drawingHint">
          üí° Tip: Even stick figures become magical!
        </div>
      </div>

      <div class="controls">
        <button class="btn btn-secondary" id="clearBtn">üóëÔ∏è Clear</button>
        <button class="btn btn-primary" id="magicBtn" disabled>
          ‚ú® Make It Magic!
        </button>
        <button class="btn btn-secondary" id="skipBtn">‚è≠Ô∏è Skip</button>
        <button class="btn btn-secondary" id="newQuestionsBtn">
          üîÑ New Questions
        </button>
      </div>

      <div class="celebration" id="celebration">
        <h2 id="celebrationTitle">üéâ Amazing!</h2>
        <div class="stars">‚≠ê‚≠ê‚≠ê</div>
        <p id="celebrationText">Your scribble became magical!</p>
        <button class="btn btn-primary" id="nextLevelBtn">
          üöÄ Next Adventure!
        </button>
      </div>

      <div class="game-state">
        <div>State: <span id="gameState">loading</span></div>
        <div>Strokes: <span id="strokeCount">0</span></div>
      </div>

      <div class="backend-status">
        <div>
          Backend:
          <span id="backendStatus" class="status-disconnected"
            >Checking...</span
          >
        </div>
      </div>
    </div>

    <script>
      class ScribbleQuest {
        constructor() {
          this.canvas = document.getElementById("canvas");
          this.ctx = this.canvas.getContext("2d");
          this.isDrawing = false;
          this.level = 1;
          this.score = 0;
          this.timeLeft = 30;
          this.strokeCount = 0;
          this.gameState = "loading";
          this.timer = null;
          this.backendAvailable = false;

          // No hardcoded challenges - purely AI generated
          this.challenges = [];
          this.currentChallenge = 0;

          this.setupCanvas();
          this.setupEventListeners();
          this.checkBackendStatus();

          // Load AI questions immediately on startup
          this.initializeGame();
        }

        async initializeGame() {
          await this.loadNewQuestions();
          this.startLevel();
        }

        async checkBackendStatus() {
          try {
            const response = await fetch("http://localhost:8000/api/health");
            if (response.ok) {
              this.backendAvailable = true;
              document.getElementById("backendStatus").textContent =
                "Connected";
              document.getElementById("backendStatus").className =
                "status-connected";
            }
          } catch (error) {
            this.backendAvailable = false;
            document.getElementById("backendStatus").textContent =
              "Simulation Mode";
            document.getElementById("backendStatus").className =
              "status-disconnected";
          }
        }

        async loadNewQuestions() {
          try {
            this.showNotification("Generating AI challenges...");

            const response = await fetch(
              "http://localhost:8000/api/generate-questions"
            );

            if (!response.ok) {
              throw new Error("Failed to generate questions");
            }

            const data = await response.json();
            console.log("Generated questions:", data.questions);

            // Convert AI questions to game format
            this.challenges = [];
            const emojis = ["üåü", "üé®", "‚ú®", "üöÄ", "ü¶ã", "üè∞", "üå∏", "üéµ"];
            const characters = ["ü¶ã", "üè∞", "üöÄ", "üå∏", "ü¶Ñ", "üåà", "üé∫", "üßÅ"];

            data.questions.forEach((q, index) => {
              if (q.trim() && q.toLowerCase().includes("draw")) {
                const emoji = emojis[index % emojis.length];
                const character = characters[index % characters.length];

                this.challenges.push({
                  text: emoji + " " + q.trim(),
                  character: character,
                  response: "Amazing! Your AI-generated drawing is magical!",
                });
              }
            });

            if (this.challenges.length > 0) {
              this.currentChallenge = 0;
              this.showNotification(
                `Loaded ${this.challenges.length} AI-generated challenges!`
              );
              console.log("Loaded challenges:", this.challenges);
            } else {
              throw new Error("No valid challenges generated");
            }
          } catch (error) {
            console.log("Failed to load AI questions:", error);
            this.showNotification(
              "Failed to generate AI questions, using backup"
            );

            // Only fallback if LLM completely fails
            this.challenges = [
              {
                text: "üåü Draw something that makes you smile!",
                character: "üé®",
                response: "Beautiful drawing!",
              },
              {
                text: "üé® Draw something round and colorful!",
                character: "üåà",
                response: "Wonderful creation!",
              },
              {
                text: "‚ú® Draw something magical!",
                character: "ü¶ã",
                response: "Amazing artwork!",
              },
            ];
            this.currentChallenge = 0;
          }
        }

        showNotification(message) {
          // Remove existing notifications
          const existingNotifications =
            document.querySelectorAll(".notification");
          existingNotifications.forEach((notif) => notif.remove());

          // Create notification element
          const notification = document.createElement("div");
          notification.className = "notification";
          notification.textContent = message;
          document.body.appendChild(notification);

          // Remove after 3 seconds
          setTimeout(() => {
            notification.style.animation = "slideOut 0.3s ease";
            setTimeout(() => notification.remove(), 300);
          }, 3000);
        }

        setupCanvas() {
          this.resizeCanvas();
          window.addEventListener("resize", () => this.resizeCanvas());

          this.ctx.strokeStyle = "#2d3436";
          this.ctx.lineWidth = 4;
          this.ctx.lineCap = "round";
          this.ctx.lineJoin = "round";
        }

        resizeCanvas() {
          const rect = this.canvas.parentElement.getBoundingClientRect();
          this.canvas.width = rect.width;
          this.canvas.height = rect.height;
        }

        setupEventListeners() {
          // Mouse events
          this.canvas.addEventListener("mousedown", (e) =>
            this.startDrawing(e)
          );
          this.canvas.addEventListener("mousemove", (e) => this.draw(e));
          this.canvas.addEventListener("mouseup", () => this.stopDrawing());
          this.canvas.addEventListener("mouseout", () => this.stopDrawing());

          // Touch events
          this.canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            this.startDrawing(e.touches[0]);
          });
          this.canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
            this.draw(e.touches[0]);
          });
          this.canvas.addEventListener("touchend", (e) => {
            e.preventDefault();
            this.stopDrawing();
          });

          // Button events
          document
            .getElementById("clearBtn")
            .addEventListener("click", () => this.clearCanvas());
          document
            .getElementById("magicBtn")
            .addEventListener("click", () => this.transformDrawing());
          document
            .getElementById("skipBtn")
            .addEventListener("click", () => this.skipChallenge());
          document
            .getElementById("nextLevelBtn")
            .addEventListener("click", () => this.nextLevel());
          document
            .getElementById("newQuestionsBtn")
            .addEventListener("click", () => this.loadNewQuestions());
        }

        getEventPos(e) {
          const rect = this.canvas.getBoundingClientRect();
          return {
            x: (e.clientX - rect.left) * (this.canvas.width / rect.width),
            y: (e.clientY - rect.top) * (this.canvas.height / rect.height),
          };
        }

        startDrawing(e) {
          if (this.gameState !== "drawing") return;

          this.isDrawing = true;
          const pos = this.getEventPos(e);
          this.ctx.beginPath();
          this.ctx.moveTo(pos.x, pos.y);

          if (this.strokeCount === 0) {
            this.hideInstruction();
            this.startTimer();
          }
        }

        draw(e) {
          if (!this.isDrawing || this.gameState !== "drawing") return;

          const pos = this.getEventPos(e);
          this.ctx.lineTo(pos.x, pos.y);
          this.ctx.stroke();

          this.strokeCount++;
          this.updateStrokeCount();
          this.enableMagicButton();
        }

        stopDrawing() {
          this.isDrawing = false;
        }

        clearCanvas() {
          this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
          this.strokeCount = 0;
          this.updateStrokeCount();
          this.disableMagicButton();
          this.showInstruction();
        }

        async transformDrawing() {
          if (this.strokeCount === 0) return;

          this.gameState = "transforming";
          this.updateGameState();
          this.disableMagicButton();
          this.clearTimer();

          this.hideInstruction();
          this.hideDrawingHint();

          // Show loading indicator
          this.showLoadingSpinner();

          if (this.backendAvailable) {
            await this.callBackendAPI();
          } else {
            this.useFallbackResponse();
          }
        }

        showLoadingSpinner() {
          document.getElementById("magicBtn").innerHTML =
            '‚ú® Creating Magic <div class="loading-spinner"></div>';
        }

        async callBackendAPI() {
          try {
            console.log("Sending drawing to backend...");

            // Capture the drawing
            const imageData = this.canvas.toDataURL("image/png");
            const currentChallenge =
              this.challenges[this.currentChallenge].text;

            const response = await fetch(
              "http://localhost:8000/api/analyze-drawing",
              {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  image: imageData,
                  challenge: currentChallenge,
                  level: this.level,
                  session_id: "test123",
                }),
              }
            );

            if (!response.ok) {
              throw new Error("Backend error");
            }

            const aiResponse = await response.json();
            console.log("Backend response:", aiResponse);

            // Show the backend response
            document.getElementById("celebrationTitle").textContent =
              aiResponse.title;
            document.getElementById("celebrationText").textContent =
              aiResponse.message + ` You earned ${aiResponse.points} points!`;

            // Check if there's a reward image from DALL-E
            if (aiResponse.reward_image) {
              // Create and display the generated image
              const rewardContainer = document.createElement("div");
              rewardContainer.className = "reward-container";

              const rewardImage = document.createElement("img");
              rewardImage.src = aiResponse.reward_image;
              rewardImage.alt = "AI Generated Artwork";
              rewardImage.onload = () => {
                console.log("DALL-E image loaded successfully");
              };
              rewardImage.onerror = () => {
                console.log("Failed to load DALL-E image");
                rewardContainer.innerHTML =
                  '<p style="color: #e17055;">Image generation completed but failed to load</p>';
              };

              const rewardText = document.createElement("p");
              rewardText.className = "reward-text";
              rewardText.textContent = "üé® Your drawing transformed into art!";

              rewardContainer.appendChild(rewardImage);
              rewardContainer.appendChild(rewardText);

              // Remove any existing reward images
              const existingReward =
                document.querySelector(".reward-container");
              if (existingReward) {
                existingReward.remove();
              }

              // Add to celebration dialog
              const celebrationText =
                document.getElementById("celebrationText");
              celebrationText.appendChild(rewardContainer);

              this.showNotification("DALL-E generated your reward image!");
            }

            setTimeout(() => {
              document.getElementById("celebration").style.display = "flex";
              this.score += aiResponse.points;
              this.updateScore();
            }, 1000);
          } catch (error) {
            console.log("Backend call failed, using fallback:", error);
            this.backendAvailable = false;
            document.getElementById("backendStatus").textContent =
              "Disconnected";
            document.getElementById("backendStatus").className =
              "status-disconnected";
            this.useFallbackResponse();
          }
        }

        useFallbackResponse() {
          // Original simulation code
          setTimeout(() => {
            this.showAICharacter();
            this.createParticles();

            setTimeout(() => {
              this.showCelebration();
            }, 1500);
          }, 1000);
        }

        showAICharacter() {
          const character = document.getElementById("aiCharacter");
          const challenge = this.challenges[this.currentChallenge];
          character.textContent = challenge.character;
          character.classList.add("show");
        }

        hideAICharacter() {
          const character = document.getElementById("aiCharacter");
          character.classList.remove("show");
        }

        createParticles() {
          const particles = ["‚ú®", "‚≠ê", "üåü", "üí´", "üéâ"];
          for (let i = 0; i < 8; i++) {
            setTimeout(() => {
              const particle = document.createElement("div");
              particle.className = "particle";
              particle.textContent =
                particles[Math.floor(Math.random() * particles.length)];
              particle.style.left = Math.random() * 80 + 10 + "%";
              particle.style.top = Math.random() * 80 + 10 + "%";
              document.body.appendChild(particle);

              setTimeout(() => particle.remove(), 2000);
            }, i * 200);
          }
        }

        showCelebration() {
          const challenge = this.challenges[this.currentChallenge];
          document.getElementById("celebrationTitle").textContent =
            "üéâ Amazing!";
          document.getElementById("celebrationText").textContent =
            challenge.response + " You earned 100 points!";
          document.getElementById("celebration").style.display = "flex";

          this.score += 100;
          this.updateScore();
        }

        hideCelebration() {
          document.getElementById("celebration").style.display = "none";
          // Clean up any reward images
          const existingReward = document.querySelector(".reward-container");
          if (existingReward) {
            existingReward.remove();
          }
        }

        skipChallenge() {
          this.nextLevel();
        }

        nextLevel() {
          this.hideCelebration();
          this.hideAICharacter();
          this.clearCanvas();
          this.level++;
          this.currentChallenge =
            (this.currentChallenge + 1) % this.challenges.length;
          this.updateLevel();
          this.startLevel();
        }

        startLevel() {
          if (this.challenges.length === 0) {
            document.getElementById("challengeText").textContent =
              "üåü Loading AI challenge...";
            return;
          }

          this.gameState = "drawing";
          this.updateGameState();
          this.timeLeft = 30;
          this.strokeCount = 0;
          this.updateStrokeCount();
          this.updateTimer();
          this.updateProgress();
          this.showInstruction();
          this.showDrawingHint();
          this.disableMagicButton();

          const challenge = this.challenges[this.currentChallenge];
          document.getElementById("challengeText").textContent = challenge.text;
        }

        startTimer() {
          this.timer = setInterval(() => {
            this.timeLeft--;
            this.updateTimer();

            if (this.timeLeft <= 0) {
              this.clearTimer();
              if (this.strokeCount > 0) {
                this.transformDrawing();
              } else {
                this.showTimeUpMessage();
              }
            }
          }, 1000);
        }

        clearTimer() {
          if (this.timer) {
            clearInterval(this.timer);
            this.timer = null;
          }
        }

        showTimeUpMessage() {
          document.getElementById("celebrationTitle").textContent =
            "‚è∞ Time's Up!";
          document.getElementById("celebrationText").textContent =
            "No worries! Every artist needs thinking time. Try the next challenge!";
          document.getElementById("celebration").style.display = "flex";
        }

        enableMagicButton() {
          const btn = document.getElementById("magicBtn");
          btn.disabled = false;
          btn.innerHTML = "‚ú® Make It Magic!";
        }

        disableMagicButton() {
          const btn = document.getElementById("magicBtn");
          btn.disabled = true;
          btn.innerHTML = "‚ú® Draw Something First!";
        }

        showInstruction() {
          document.getElementById("instruction").style.display = "block";
        }

        hideInstruction() {
          document.getElementById("instruction").style.display = "none";
        }

        showDrawingHint() {
          document.getElementById("drawingHint").style.display = "block";
        }

        hideDrawingHint() {
          document.getElementById("drawingHint").style.display = "none";
        }

        updateLevel() {
          document.getElementById("levelNumber").textContent = this.level;
        }

        updateScore() {
          document.getElementById("score").textContent = this.score;
        }

        updateTimer() {
          document.getElementById("timer").textContent = this.timeLeft;
        }

        updateStrokeCount() {
          document.getElementById("strokeCount").textContent = this.strokeCount;
        }

        updateGameState() {
          document.getElementById("gameState").textContent = this.gameState;
        }

        updateProgress() {
          const progress = (this.level - 1) * 12.5;
          document.getElementById("progressFill").style.width =
            Math.min(progress, 100) + "%";
        }
      }

      // Initialize game when page loads
      
      let game;
      window.addEventListener("load", () => {
        game = new ScribbleQuest();
      });
    </script>
  </body>
</html>
